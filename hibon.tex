\section{HiBON Data format}
\label{sec:hibon}
All data exchanged and stored in the network is structured using a data format called \abbrev{HiBON}{Hash-invariant Binary Object Notation} which is inspired by \abbrev{BSON}{Binary JSON}, but the two formats are not compatible. In HiBON the keys are sorted according to the ordering rules described below (in D-lang). By ordering the keys, the data is hash invariant for the same collection.\\
%The algorithm use to order the key is shown below (D-lang):

\lstset{language=c++, numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, tabsize=4}%, 
\begin{lstlisting}
/**
This function decides the order of the HiBON keys
Returns:
true if the value of key a is less than the value of key b
*/
@safe @nogc bool less_than(string a, string b) pure nothrow
	in {
		assert(a.length > 0);
		assert(b.length > 0);
	}
	do {
		uint a_index;
		uint b_index;
		if (is_index(a, a_index) && is_index(b, b_index)) {
			return a_index < b_index;
		}
	return a < b;
	}

/**
Converts from a text to a index
Params:
a = the string to be converted to an index
result = index value
Returns:
true if a is an index
*/
@safe @nogc bool is_index(const(char[]) a, out uint result) pure nothrow {
	import std.conv: to;

	enum MAX_UINT_SIZE = to!string(uint.max).length;
	@nogc @safe static ulong to_ulong(const(char[]) a) pure nothrow {
		ulong result;
		foreach (c; a) {
			result *= 10;
			result += (c - '0');
		}
		return result;
	}

	if (a.length <= MAX_UINT_SIZE) {
		if ((a[0] is '0') && (a.length > 1)) {
			return false;
		}
		foreach (c; a) {
			if ((c < '0') || (c > '9')) {
				return false;
			}
		}
		immutable number = to_ulong(a);
		if (number <= uint.max) {
			result = cast(uint) number;
			return true;
		}
	}
	return false;
}
\end{lstlisting}

Only printable ASCII keys are allowed to be used as keys in the HiBON; this means no control characters or special characters allowed. The key is validated accordingly to the function described below.
\begin{lstlisting}
/**
Checks if the keys in the range is ordred
Returns:
ture if all keys in the range is ordered
*/
@safe bool is_key_ordered(R)(R range) if (isInputRange!R) {
	string prev_key;
	while (!range.empty) {
		if ((prev_key.length == 0) || (less_than(prev_key, range.front))) {
			prev_key = range.front;
			range.popFront;
		}
		else {
			return false;
		}
	}
	return true;
}
\end{lstlisting}


\input{tab_hibon}

Any data types which are not defined in \cref{tab:hibon} are illegal and must be rejected by the network. The types used in the table are primarily the types used in D except for a few as \texttt{\{\}} and \texttt{[]}.

\subsection{HRPC â€“ HiBON Remote Procedure Call}
HRPC works like JSON-RPC just with signed binary data, the above-defined HiBON format. It means the data is hash-invariant enabling hash- and signature functions to be executed quickly and unambiguously.

\begin{table}[H]
\begin{center}
\begin{tabular}{|l|p{7cm}|p{1.5cm}|l|}
      \hline
      Parameter & Description & Type & Access \\
      \hline
      $\$type$ & Set contract type to 'HRPC' &  \texttt{string} & \texttt{ro} \\
      \hline
      $\$pkey$ & Public key &  \texttt{bin} & \texttt{ro} \\
      \hline
      $\$sign$ & Signature of $\$msg$ &  \texttt{bin} & \texttt{ro} \\
      \hline
      $\$msg$ & Message object \cref{tab:HRPC_method_message}, \cref{tab:HRPC_success_message}, \cref{tab:HRPC_error_message} &  \texttt{\{\}} & \texttt{ro} \\
      \hline
  \end{tabular}
\end{center}
\caption{HRPC format} 
\label{tab:HRPC_format}
\end{table}

\begin{table}[H]
\begin{center}
\begin{tabular}{|l|p{7cm}|p{1.5cm}|l|}
      \hline
      Parameter & Description & Type & Access \\
      \hline
      $\$id$ & Message id  &  \texttt{uint} & \texttt{ro} \\
      \hline
      $\$method$ & Name of remote call function &  \texttt{string} & \texttt{ro} \\
      \hline
      $\$params$ & Params for the \$method function (optional) &  \texttt{\{\}} & \texttt{ro} \\
      \hline
  \end{tabular}
\end{center}
\caption{HRPC method message object} 
\label{tab:HRPC_method_message}
\end{table}

\begin{table}[H]
\begin{center}
\begin{tabular}{|l|p{7cm}|p{1.5cm}|l|}
      \hline
      Parameter & Description & Type & Access \\
      \hline
      $\$id$ & Message id &  \texttt{uint} & \texttt{ro} \\
      \hline
      $\$result$ & Result of the $\$method$ call &  \texttt{\{\}} & \texttt{ro} \\
      \hline
  \end{tabular}
\end{center}
\caption{HRPC success message object } 
\label{tab:HRPC_success_message}
\end{table}

\begin{table}[H]
\begin{center}
\begin{tabular}{|l|p{7cm}|p{1.5cm}|l|}
      \hline
      Parameter & Description & Type & Access \\
      \hline
      $\$id$ & Message id & \texttt{string} & \texttt{ro} \\
      \hline
      $\$msg$ & Error object \cref{tab:HRPC_error} & \texttt{\{\}} & \texttt{ro} \\
      \hline
  \end{tabular}
\end{center}
\caption{HPPC error response object } 
\label{tab:HRPC_error_message}
\end{table}


\begin{table}[H]
\begin{center}
\begin{tabular}{|l|p{7cm}|p{1.5cm}|l|}
      \hline
      Parameter & Description & Type & Access \\
      \hline
      $\$code$ & Set contract type to 'HRPC' & \texttt{uint} & \texttt{ro} \\
      \hline
      $\$msg$ & Error message  & \texttt{string} & \texttt{ro} \\
      \hline
      $\$data$ & Data object (optional) & \texttt{[]} & \texttt{ro} \\
      \hline
  \end{tabular}
\end{center}
\caption{HRPC error object } 
\label{tab:HRPC_error}
\end{table}
